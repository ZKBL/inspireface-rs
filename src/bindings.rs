/* automatically generated by rust-bindgen 0.70.0 */

pub const HSUCCEED: u32 = 0;
pub const HERR_BASIC_BASE: u32 = 1;
pub const HERR_UNKNOWN: u32 = 1;
pub const HERR_INVALID_PARAM: u32 = 2;
pub const HERR_INVALID_IMAGE_STREAM_HANDLE: u32 = 25;
pub const HERR_INVALID_CONTEXT_HANDLE: u32 = 26;
pub const HERR_INVALID_FACE_TOKEN: u32 = 31;
pub const HERR_INVALID_FACE_FEATURE: u32 = 32;
pub const HERR_INVALID_FACE_LIST: u32 = 33;
pub const HERR_INVALID_BUFFER_SIZE: u32 = 34;
pub const HERR_INVALID_IMAGE_STREAM_PARAM: u32 = 35;
pub const HERR_INVALID_SERIALIZATION_FAILED: u32 = 36;
pub const HERR_INVALID_DETECTION_INPUT: u32 = 37;
pub const HERR_SESS_BASE: u32 = 1280;
pub const HERR_SESS_FUNCTION_UNUSABLE: u32 = 1282;
pub const HERR_SESS_TRACKER_FAILURE: u32 = 1283;
pub const HERR_SESS_INVALID_RESOURCE: u32 = 1290;
pub const HERR_SESS_NUM_OF_MODELS_NOT_MATCH: u32 = 1291;
pub const HERR_SESS_LANDMARK_NUM_NOT_MATCH: u32 = 1300;
pub const HERR_SESS_PIPELINE_FAILURE: u32 = 1288;
pub const HERR_SESS_REC_EXTRACT_FAILURE: u32 = 1295;
pub const HERR_SESS_REC_DEL_FAILURE: u32 = 1296;
pub const HERR_SESS_REC_UPDATE_FAILURE: u32 = 1297;
pub const HERR_SESS_REC_ADD_FEAT_EMPTY: u32 = 1298;
pub const HERR_SESS_REC_FEAT_SIZE_ERR: u32 = 1299;
pub const HERR_SESS_REC_INVALID_INDEX: u32 = 1300;
pub const HERR_SESS_REC_CONTRAST_FEAT_ERR: u32 = 1303;
pub const HERR_SESS_REC_BLOCK_FULL: u32 = 1304;
pub const HERR_SESS_REC_BLOCK_DEL_FAILURE: u32 = 1305;
pub const HERR_SESS_REC_BLOCK_UPDATE_FAILURE: u32 = 1306;
pub const HERR_SESS_REC_ID_ALREADY_EXIST: u32 = 1307;
pub const HERR_SESS_FACE_DATA_ERROR: u32 = 1310;
pub const HERR_SESS_FACE_REC_OPTION_ERROR: u32 = 1320;
pub const HERR_FT_HUB_DISABLE: u32 = 1329;
pub const HERR_FT_HUB_OPEN_ERROR: u32 = 1330;
pub const HERR_FT_HUB_NOT_OPENED: u32 = 1331;
pub const HERR_FT_HUB_NO_RECORD_FOUND: u32 = 1332;
pub const HERR_FT_HUB_CHECK_TABLE_ERROR: u32 = 1333;
pub const HERR_FT_HUB_INSERT_FAILURE: u32 = 1334;
pub const HERR_FT_HUB_PREPARING_FAILURE: u32 = 1335;
pub const HERR_FT_HUB_EXECUTING_FAILURE: u32 = 1336;
pub const HERR_FT_HUB_NOT_VALID_FOLDER_PATH: u32 = 1337;
pub const HERR_FT_HUB_ENABLE_REPETITION: u32 = 1338;
pub const HERR_FT_HUB_DISABLE_REPETITION: u32 = 1339;
pub const HERR_ARCHIVE_LOAD_FAILURE: u32 = 1360;
pub const HERR_ARCHIVE_LOAD_MODEL_FAILURE: u32 = 1361;
pub const HERR_ARCHIVE_FILE_FORMAT_ERROR: u32 = 1362;
pub const HERR_ARCHIVE_REPETITION_LOAD: u32 = 1363;
pub const HERR_ARCHIVE_NOT_LOAD: u32 = 1364;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const HF_ENABLE_NONE: u32 = 0;
pub const HF_ENABLE_FACE_RECOGNITION: u32 = 2;
pub const HF_ENABLE_LIVENESS: u32 = 4;
pub const HF_ENABLE_IR_LIVENESS: u32 = 8;
pub const HF_ENABLE_MASK_DETECT: u32 = 16;
pub const HF_ENABLE_FACE_ATTRIBUTE: u32 = 32;
pub const HF_ENABLE_PLACEHOLDER_: u32 = 64;
pub const HF_ENABLE_QUALITY: u32 = 128;
pub const HF_ENABLE_INTERACTION: u32 = 256;
pub type HPVoid = *mut ::std::os::raw::c_void;
pub type HFImageStream = *mut ::std::os::raw::c_void;
pub type HFSession = *mut ::std::os::raw::c_void;
pub type HLong = ::std::os::raw::c_long;
pub type HFloat = f32;
pub type HPFloat = *mut f32;
pub type HDouble = f64;
pub type HUInt8 = ::std::os::raw::c_uchar;
pub type HInt32 = ::std::os::raw::c_int;
pub type HOption = ::std::os::raw::c_int;
pub type HPInt32 = *mut ::std::os::raw::c_int;
pub type HResult = ::std::os::raw::c_long;
pub type HString = *mut ::std::os::raw::c_char;
pub type HPath = *const ::std::os::raw::c_char;
pub type HBuffer = ::std::os::raw::c_char;
pub type HPBuffer = *mut ::std::os::raw::c_char;
pub type HSize = ::std::os::raw::c_long;
pub type HPSize = *mut ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFaceRect {
    #[doc = "< X-coordinate of the top-left corner of the rectangle."]
    pub x: HInt32,
    #[doc = "< Y-coordinate of the top-left corner of the rectangle."]
    pub y: HInt32,
    #[doc = "< Width of the rectangle."]
    pub width: HInt32,
    #[doc = "< Height of the rectangle."]
    pub height: HInt32,
}
const _: () = {
    ["Size of HFaceRect"][::std::mem::size_of::<HFaceRect>() - 16usize];
    ["Alignment of HFaceRect"][::std::mem::align_of::<HFaceRect>() - 4usize];
    ["Offset of field: HFaceRect::x"][::std::mem::offset_of!(HFaceRect, x) - 0usize];
    ["Offset of field: HFaceRect::y"][::std::mem::offset_of!(HFaceRect, y) - 4usize];
    ["Offset of field: HFaceRect::width"][::std::mem::offset_of!(HFaceRect, width) - 8usize];
    ["Offset of field: HFaceRect::height"][::std::mem::offset_of!(HFaceRect, height) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HPoint2f {
    #[doc = "< X-coordinate"]
    pub x: HFloat,
    #[doc = "< Y-coordinate"]
    pub y: HFloat,
}
const _: () = {
    ["Size of HPoint2f"][::std::mem::size_of::<HPoint2f>() - 8usize];
    ["Alignment of HPoint2f"][::std::mem::align_of::<HPoint2f>() - 4usize];
    ["Offset of field: HPoint2f::x"][::std::mem::offset_of!(HPoint2f, x) - 0usize];
    ["Offset of field: HPoint2f::y"][::std::mem::offset_of!(HPoint2f, y) - 4usize];
};
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = "< Image in RGB format."]
pub const HFImageFormat_HF_STREAM_RGB: HFImageFormat = 0;
#[doc = "< Image in BGR format (Opencv Mat default)."]
pub const HFImageFormat_HF_STREAM_BGR: HFImageFormat = 1;
#[doc = "< Image in RGB format with alpha channel."]
pub const HFImageFormat_HF_STREAM_RGBA: HFImageFormat = 2;
#[doc = "< Image in BGR format with alpha channel."]
pub const HFImageFormat_HF_STREAM_BGRA: HFImageFormat = 3;
#[doc = "< Image in YUV NV12 format."]
pub const HFImageFormat_HF_STREAM_YUV_NV12: HFImageFormat = 4;
#[doc = "< Image in YUV NV21 format."]
pub const HFImageFormat_HF_STREAM_YUV_NV21: HFImageFormat = 5;
#[doc = " Camera stream format.\n Contains several common camera stream formats available in the market."]
pub type HFImageFormat = ::std::os::raw::c_uint;
#[doc = "< 0 degree rotation."]
pub const HFRotation_HF_CAMERA_ROTATION_0: HFRotation = 0;
#[doc = "< 90 degree rotation."]
pub const HFRotation_HF_CAMERA_ROTATION_90: HFRotation = 1;
#[doc = "< 180 degree rotation."]
pub const HFRotation_HF_CAMERA_ROTATION_180: HFRotation = 2;
#[doc = "< 270 degree rotation."]
pub const HFRotation_HF_CAMERA_ROTATION_270: HFRotation = 3;
#[doc = " Camera picture rotation mode.\n To accommodate the rotation of certain devices, four image rotation modes are provided."]
pub type HFRotation = ::std::os::raw::c_uint;
#[doc = " Image Buffer Data structure.\n Defines the structure for image data stream."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFImageData {
    #[doc = "< Pointer to the image data stream."]
    pub data: *mut u8,
    #[doc = "< Width of the image."]
    pub width: HInt32,
    #[doc = "< Height of the image."]
    pub height: HInt32,
    #[doc = "< Format of the image, indicating the data stream format to be parsed."]
    pub format: HFImageFormat,
    #[doc = "< Rotation angle of the image."]
    pub rotation: HFRotation,
}
const _: () = {
    ["Size of HFImageData"][::std::mem::size_of::<HFImageData>() - 24usize];
    ["Alignment of HFImageData"][::std::mem::align_of::<HFImageData>() - 8usize];
    ["Offset of field: HFImageData::data"][::std::mem::offset_of!(HFImageData, data) - 0usize];
    ["Offset of field: HFImageData::width"][::std::mem::offset_of!(HFImageData, width) - 8usize];
    ["Offset of field: HFImageData::height"][::std::mem::offset_of!(HFImageData, height) - 12usize];
    ["Offset of field: HFImageData::format"][::std::mem::offset_of!(HFImageData, format) - 16usize];
    ["Offset of field: HFImageData::rotation"]
        [::std::mem::offset_of!(HFImageData, rotation) - 20usize];
};
#[doc = " Image Buffer Data structure.\n Defines the structure for image data stream."]
pub type PHFImageData = *mut HFImageData;
extern "C" {
    #[doc = " @brief Create a data buffer stream instantiation object.\n\n This function is used to create an instance of a data buffer stream with the given image data.\n\n @param data Pointer to the image buffer data structure.\n @param handle Pointer to the stream handle that will be returned.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFCreateImageStream(data: PHFImageData, handle: *mut HFImageStream) -> HResult;
}
extern "C" {
    #[doc = " @brief Release the instantiated DataBuffer object.\n\n This function is used to release the DataBuffer object that has been previously instantiated.\n\n @param streamHandle Pointer to the DataBuffer handle representing the camera stream component.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFReleaseImageStream(streamHandle: HFImageStream) -> HResult;
}
extern "C" {
    #[doc = " @brief Launch InspireFace SDK\n Start the InspireFace SDK at the initialization stage of your program, as it is global and\n designed to be used only once. It serves as a prerequisite for other function interfaces, so it\n is essential to ensure it is initialized before calling any other APIs.\n @param resourcePath Initializes the path to the resource file that needs to be loaded\n @return HResult indicating the success or failure of the operation."]
    pub fn HFLaunchInspireFace(resourcePath: HPath) -> HResult;
}
extern "C" {
    #[doc = " @brief Terminate InspireFace SDK\n Terminate the InspireFace SDK, releasing all allocated resources.\n This should be called at the end of your program to ensure proper cleanup.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFTerminateInspireFace() -> HResult;
}
#[doc = " @brief Struct for custom parameters in face recognition context.\n\n This struct holds various flags to enable or disable specific features\n in the face recognition context, such as face recognition, liveness detection,\n mask detection, age and gender prediction, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFSessionCustomParameter {
    #[doc = "< Enable face recognition feature."]
    pub enable_recognition: HInt32,
    #[doc = "< Enable RGB liveness detection feature."]
    pub enable_liveness: HInt32,
    #[doc = "< Enable IR liveness detection feature."]
    pub enable_ir_liveness: HInt32,
    #[doc = "< Enable mask detection feature."]
    pub enable_mask_detect: HInt32,
    #[doc = "< Enable face quality detection feature."]
    pub enable_face_quality: HInt32,
    #[doc = "< Enable face attribute prediction feature."]
    pub enable_face_attribute: HInt32,
    #[doc = "< Enable interaction for liveness detection feature."]
    pub enable_interaction_liveness: HInt32,
}
const _: () = {
    ["Size of HFSessionCustomParameter"]
        [::std::mem::size_of::<HFSessionCustomParameter>() - 28usize];
    ["Alignment of HFSessionCustomParameter"]
        [::std::mem::align_of::<HFSessionCustomParameter>() - 4usize];
    ["Offset of field: HFSessionCustomParameter::enable_recognition"]
        [::std::mem::offset_of!(HFSessionCustomParameter, enable_recognition) - 0usize];
    ["Offset of field: HFSessionCustomParameter::enable_liveness"]
        [::std::mem::offset_of!(HFSessionCustomParameter, enable_liveness) - 4usize];
    ["Offset of field: HFSessionCustomParameter::enable_ir_liveness"]
        [::std::mem::offset_of!(HFSessionCustomParameter, enable_ir_liveness) - 8usize];
    ["Offset of field: HFSessionCustomParameter::enable_mask_detect"]
        [::std::mem::offset_of!(HFSessionCustomParameter, enable_mask_detect) - 12usize];
    ["Offset of field: HFSessionCustomParameter::enable_face_quality"]
        [::std::mem::offset_of!(HFSessionCustomParameter, enable_face_quality) - 16usize];
    ["Offset of field: HFSessionCustomParameter::enable_face_attribute"]
        [::std::mem::offset_of!(HFSessionCustomParameter, enable_face_attribute) - 20usize];
    ["Offset of field: HFSessionCustomParameter::enable_interaction_liveness"]
        [::std::mem::offset_of!(HFSessionCustomParameter, enable_interaction_liveness) - 24usize];
};
#[doc = " @brief Struct for custom parameters in face recognition context.\n\n This struct holds various flags to enable or disable specific features\n in the face recognition context, such as face recognition, liveness detection,\n mask detection, age and gender prediction, etc."]
pub type PHFSessionCustomParameter = *mut HFSessionCustomParameter;
#[doc = "< Image detection mode, always detect, applicable to images."]
pub const HFDetectMode_HF_DETECT_MODE_ALWAYS_DETECT: HFDetectMode = 0;
#[doc = "< Video detection mode, face tracking, applicable to video\n< streaming, front camera."]
pub const HFDetectMode_HF_DETECT_MODE_LIGHT_TRACK: HFDetectMode = 1;
#[doc = "< Video detection mode, face tracking, applicable to high\n< resolution, monitoring, capturing"]
pub const HFDetectMode_HF_DETECT_MODE_TRACK_BY_DETECTION: HFDetectMode = 2;
#[doc = " @brief Enumeration for face detection modes."]
pub type HFDetectMode = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Create a session from a resource file.\n\n @param parameter Custom parameters for session.\n @param detectMode Detection mode to be used.\n @param maxDetectFaceNum Maximum number of faces to detect.\n @param detectPixelLevel Modify the input resolution level of the detector, the larger the better,\n          the need to input a multiple of 160, such as 160, 320, 640, the default value -1 is 320.\n @param trackByDetectModeFPS If you are using the MODE_TRACK_BY_DETECTION tracking mode,\n          this value is used to set the fps frame rate of your current incoming video stream,\n which defaults to -1 at 30fps.\n @param handle Pointer to the context handle that will be returned.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFCreateInspireFaceSession(
        parameter: HFSessionCustomParameter,
        detectMode: HFDetectMode,
        maxDetectFaceNum: HInt32,
        detectPixelLevel: HInt32,
        trackByDetectModeFPS: HInt32,
        handle: *mut HFSession,
    ) -> HResult;
}
extern "C" {
    #[doc = " @brief Create a session from a resource file with additional options.\n\n @param customOption Custom option for additional configuration.\n @param detectMode Detection mode to be used.\n @param maxDetectFaceNum Maximum number of faces to detect.\n @param detectPixelLevel Modify the input resolution level of the detector, the larger the better,\n          the need to input a multiple of 160, such as 160, 320, 640, the default value -1 is 320.\n @param trackByDetectModeFPS If you are using the MODE_TRACK_BY_DETECTION tracking mode,\n          this value is used to set the fps frame rate of your current incoming video stream,\n which defaults to -1 at 30fps.\n @param handle Pointer to the context handle that will be returned.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFCreateInspireFaceSessionOptional(
        customOption: HOption,
        detectMode: HFDetectMode,
        maxDetectFaceNum: HInt32,
        detectPixelLevel: HInt32,
        trackByDetectModeFPS: HInt32,
        handle: *mut HFSession,
    ) -> HResult;
}
extern "C" {
    #[doc = " @brief Release the session.\n\n @param handle Handle to the session to be released.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFReleaseInspireFaceSession(handle: HFSession) -> HResult;
}
#[doc = " @brief Struct representing a basic token for face data.\n\n This struct holds the size and data pointer for a basic token associated with face data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFFaceBasicToken {
    #[doc = "< Size of the token."]
    pub size: HInt32,
    #[doc = "< Pointer to the token data."]
    pub data: HPVoid,
}
const _: () = {
    ["Size of HFFaceBasicToken"][::std::mem::size_of::<HFFaceBasicToken>() - 16usize];
    ["Alignment of HFFaceBasicToken"][::std::mem::align_of::<HFFaceBasicToken>() - 8usize];
    ["Offset of field: HFFaceBasicToken::size"]
        [::std::mem::offset_of!(HFFaceBasicToken, size) - 0usize];
    ["Offset of field: HFFaceBasicToken::data"]
        [::std::mem::offset_of!(HFFaceBasicToken, data) - 8usize];
};
#[doc = " @brief Struct representing a basic token for face data.\n\n This struct holds the size and data pointer for a basic token associated with face data."]
pub type PHFFaceBasicToken = *mut HFFaceBasicToken;
#[doc = " @brief Struct for face Euler angles.\n\n This struct represents the Euler angles (roll, yaw, pitch) for face orientation."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFFaceEulerAngle {
    #[doc = "< Roll angle of the face."]
    pub roll: *mut HFloat,
    #[doc = "< Yaw angle of the face."]
    pub yaw: *mut HFloat,
    #[doc = "< Pitch angle of the face."]
    pub pitch: *mut HFloat,
}
const _: () = {
    ["Size of HFFaceEulerAngle"][::std::mem::size_of::<HFFaceEulerAngle>() - 24usize];
    ["Alignment of HFFaceEulerAngle"][::std::mem::align_of::<HFFaceEulerAngle>() - 8usize];
    ["Offset of field: HFFaceEulerAngle::roll"]
        [::std::mem::offset_of!(HFFaceEulerAngle, roll) - 0usize];
    ["Offset of field: HFFaceEulerAngle::yaw"]
        [::std::mem::offset_of!(HFFaceEulerAngle, yaw) - 8usize];
    ["Offset of field: HFFaceEulerAngle::pitch"]
        [::std::mem::offset_of!(HFFaceEulerAngle, pitch) - 16usize];
};
#[doc = " @brief Struct for holding data of multiple detected faces.\n\n This struct stores the data related to multiple faces detected, including the number of faces,\n their bounding rectangles, track IDs, angles, and tokens."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFMultipleFaceData {
    #[doc = "< Number of faces detected."]
    pub detectedNum: HInt32,
    #[doc = "< Array of bounding rectangles for each face."]
    pub rects: *mut HFaceRect,
    #[doc = "< Array of track IDs for each face."]
    pub trackIds: *mut HInt32,
    #[doc = "< Euler angles for each face."]
    pub angles: HFFaceEulerAngle,
    #[doc = "< Tokens associated with each face."]
    pub tokens: PHFFaceBasicToken,
}
const _: () = {
    ["Size of HFMultipleFaceData"][::std::mem::size_of::<HFMultipleFaceData>() - 56usize];
    ["Alignment of HFMultipleFaceData"][::std::mem::align_of::<HFMultipleFaceData>() - 8usize];
    ["Offset of field: HFMultipleFaceData::detectedNum"]
        [::std::mem::offset_of!(HFMultipleFaceData, detectedNum) - 0usize];
    ["Offset of field: HFMultipleFaceData::rects"]
        [::std::mem::offset_of!(HFMultipleFaceData, rects) - 8usize];
    ["Offset of field: HFMultipleFaceData::trackIds"]
        [::std::mem::offset_of!(HFMultipleFaceData, trackIds) - 16usize];
    ["Offset of field: HFMultipleFaceData::angles"]
        [::std::mem::offset_of!(HFMultipleFaceData, angles) - 24usize];
    ["Offset of field: HFMultipleFaceData::tokens"]
        [::std::mem::offset_of!(HFMultipleFaceData, tokens) - 48usize];
};
#[doc = " @brief Struct for holding data of multiple detected faces.\n\n This struct stores the data related to multiple faces detected, including the number of faces,\n their bounding rectangles, track IDs, angles, and tokens."]
pub type PHFMultipleFaceData = *mut HFMultipleFaceData;
extern "C" {
    #[doc = " @brief Set the track preview size in the session, it works with face detection and tracking\n algorithms. Default preview size is 192(px).\n\n @param session Handle to the session.\n @param previewSize The size of the preview for tracking.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFSessionSetTrackPreviewSize(session: HFSession, previewSize: HInt32) -> HResult;
}
extern "C" {
    #[doc = " @brief Set the minimum number of face pixels that the face detector can capture, and people below\n this number will be filtered.\n\n @param session Handle to the session.\n @param minSize The minimum pixel value, default value is 24.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFSessionSetFilterMinimumFacePixelSize(session: HFSession, minSize: HInt32) -> HResult;
}
extern "C" {
    #[doc = " @brief Set the face detect threshold in the session.\n\n @param session Handle to the session.\n @param detectMode The mode of the detection mode for tracking.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFSessionSetFaceDetectThreshold(session: HFSession, threshold: HFloat) -> HResult;
}
extern "C" {
    #[doc = " @brief Run face tracking in the session.\n\n @param session Handle to the session.\n @param streamHandle Handle to the data buffer representing the camera stream component.\n @param results Pointer to the structure where the results will be stored.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFExecuteFaceTrack(
        session: HFSession,
        streamHandle: HFImageStream,
        results: PHFMultipleFaceData,
    ) -> HResult;
}
extern "C" {
    #[doc = " @brief Copies the data from a HF_FaceBasicToken to a specified buffer.\n\n This function copies the data pointed to by the HF_FaceBasicToken's data field\n into a user-provided buffer. The caller is responsible for ensuring that the buffer\n is large enough to hold the data being copied.\n\n @param token The HF_FaceBasicToken containing the data to be copied.\n @param buffer The buffer where the data will be copied to.\n @param bufferSize The size of the buffer provided by the caller. Must be large enough\n        to hold the data pointed to by the token's data field.\n @return HResult indicating the success or failure of the operation. Returns HSUCCEED\n         if the operation was successful, or an error code if the buffer was too small\n         or if any other error occurred."]
    pub fn HFCopyFaceBasicToken(
        token: HFFaceBasicToken,
        buffer: HPBuffer,
        bufferSize: HInt32,
    ) -> HResult;
}
extern "C" {
    #[doc = " @brief Retrieves the size of the data contained in a HF_FaceBasicToken.\n\n This function is used to query the size of the data that a HF_FaceBasicToken is\n expected to contain. This is useful for allocating a buffer of appropriate size\n before copying data from a HF_FaceBasicToken.\n\n @param bufferSize Pointer to an integer where the size of the data will be stored.\n        On successful completion, this will contain the size of the data in bytes.\n @return HResult indicating the success or failure of the operation. Returns HSUCCEED\n         if the operation was successful, or an error code if it failed."]
    pub fn HFGetFaceBasicTokenSize(bufferSize: HPInt32) -> HResult;
}
extern "C" {
    #[doc = " @brief Retrieve the number of dense facial landmarks.\n @param num Number of dense facial landmarks\n @return HResult indicating the success or failure of the operation."]
    pub fn HFGetNumOfFaceDenseLandmark(num: HPInt32) -> HResult;
}
extern "C" {
    #[doc = " @brief When you pass in a valid facial token, you can retrieve a set of dense facial landmarks.\n          The memory for the dense landmarks must be allocated by you.\n @param singleFace Basic token representing a single face.\n @param landmarks Pre-allocated memory address of the array for 2D floating-point coordinates.\n @param num Number of landmark points\n @return HResult indicating the success or failure of the operation."]
    pub fn HFGetFaceDenseLandmarkFromFaceToken(
        singleFace: HFFaceBasicToken,
        landmarks: *mut HPoint2f,
        num: HInt32,
    ) -> HResult;
}
#[doc = " @brief Struct representing a face feature.\n\n This struct holds the data related to a face feature, including size and actual feature data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFFaceFeature {
    #[doc = "< Size of the feature data."]
    pub size: HInt32,
    #[doc = "< Pointer to the feature data."]
    pub data: HPFloat,
}
const _: () = {
    ["Size of HFFaceFeature"][::std::mem::size_of::<HFFaceFeature>() - 16usize];
    ["Alignment of HFFaceFeature"][::std::mem::align_of::<HFFaceFeature>() - 8usize];
    ["Offset of field: HFFaceFeature::size"][::std::mem::offset_of!(HFFaceFeature, size) - 0usize];
    ["Offset of field: HFFaceFeature::data"][::std::mem::offset_of!(HFFaceFeature, data) - 8usize];
};
#[doc = " @brief Struct representing a face feature.\n\n This struct holds the data related to a face feature, including size and actual feature data."]
pub type PHFFaceFeature = *mut HFFaceFeature;
extern "C" {
    #[doc = " @brief Extract a face feature from a given face.\n\n @param session Handle to the session.\n @param streamHandle Handle to the data buffer representing the camera stream component.\n @param singleFace Basic token representing a single face.\n @param feature Pointer to the extracted face feature.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFFaceFeatureExtract(
        session: HFSession,
        streamHandle: HFImageStream,
        singleFace: HFFaceBasicToken,
        feature: PHFFaceFeature,
    ) -> HResult;
}
extern "C" {
    #[doc = " @brief Extract a face feature from a given face and copy it to the provided feature buffer.\n\n @param session Handle to the session.\n @param streamHandle Handle to the data buffer representing the camera stream component.\n @param singleFace Basic token representing a single face.\n @param feature Pointer to the buffer where the extracted feature will be copied.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFFaceFeatureExtractCpy(
        session: HFSession,
        streamHandle: HFImageStream,
        singleFace: HFFaceBasicToken,
        feature: HPFloat,
    ) -> HResult;
}
pub const HFSearchMode_HF_SEARCH_MODE_EAGER: HFSearchMode = 0;
pub const HFSearchMode_HF_SEARCH_MODE_EXHAUSTIVE: HFSearchMode = 1;
#[doc = " @brief Select the search mode in the process of face recognition search,\n and different modes will affect the execution efficiency and results"]
pub type HFSearchMode = ::std::os::raw::c_uint;
#[doc = " @brief Struct for database configuration.\n\n This struct holds the configuration settings for using a database in the face recognition\n context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFFeatureHubConfiguration {
    #[doc = "< The order of magnitude of face feature database is N * 512, and 20\n< is recommended by default"]
    pub featureBlockNum: HInt32,
    #[doc = "< Flag to enable or disable the use of the database."]
    pub enablePersistence: HInt32,
    #[doc = "< Path to the database file."]
    pub dbPath: HString,
    #[doc = "< Threshold for face search"]
    pub searchThreshold: f32,
    #[doc = "< Mode of face search"]
    pub searchMode: HFSearchMode,
}
const _: () = {
    ["Size of HFFeatureHubConfiguration"]
        [::std::mem::size_of::<HFFeatureHubConfiguration>() - 24usize];
    ["Alignment of HFFeatureHubConfiguration"]
        [::std::mem::align_of::<HFFeatureHubConfiguration>() - 8usize];
    ["Offset of field: HFFeatureHubConfiguration::featureBlockNum"]
        [::std::mem::offset_of!(HFFeatureHubConfiguration, featureBlockNum) - 0usize];
    ["Offset of field: HFFeatureHubConfiguration::enablePersistence"]
        [::std::mem::offset_of!(HFFeatureHubConfiguration, enablePersistence) - 4usize];
    ["Offset of field: HFFeatureHubConfiguration::dbPath"]
        [::std::mem::offset_of!(HFFeatureHubConfiguration, dbPath) - 8usize];
    ["Offset of field: HFFeatureHubConfiguration::searchThreshold"]
        [::std::mem::offset_of!(HFFeatureHubConfiguration, searchThreshold) - 16usize];
    ["Offset of field: HFFeatureHubConfiguration::searchMode"]
        [::std::mem::offset_of!(HFFeatureHubConfiguration, searchMode) - 20usize];
};
extern "C" {
    #[doc = " @brief A lightweight face feature vector management.\n @details FeatureHub is a built-in global lightweight face feature vector management functionality\n provided in the InspireFace-SDK. It supports basic face feature search, deletion, and\n modification functions, and offers two optional data storage modes: an in-memory model and a\n persistence model. If you have simple storage needs, you can enable it.\n\n @param configuration FeatureHub configuration details.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFFeatureHubDataEnable(configuration: HFFeatureHubConfiguration) -> HResult;
}
extern "C" {
    #[doc = " @brief Disable the global FeatureHub feature, and you can enable it again if needed.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFFeatureHubDataDisable() -> HResult;
}
#[doc = " @brief Struct representing the identity of a face feature.\n\n This struct associates a custom identifier and a tag with a specific face feature."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFFaceFeatureIdentity {
    #[doc = "< Custom identifier for the face feature."]
    pub customId: HInt32,
    #[doc = "< Tag associated with the face feature."]
    pub tag: HString,
    #[doc = "< Pointer to the face feature."]
    pub feature: PHFFaceFeature,
}
const _: () = {
    ["Size of HFFaceFeatureIdentity"][::std::mem::size_of::<HFFaceFeatureIdentity>() - 24usize];
    ["Alignment of HFFaceFeatureIdentity"]
        [::std::mem::align_of::<HFFaceFeatureIdentity>() - 8usize];
    ["Offset of field: HFFaceFeatureIdentity::customId"]
        [::std::mem::offset_of!(HFFaceFeatureIdentity, customId) - 0usize];
    ["Offset of field: HFFaceFeatureIdentity::tag"]
        [::std::mem::offset_of!(HFFaceFeatureIdentity, tag) - 8usize];
    ["Offset of field: HFFaceFeatureIdentity::feature"]
        [::std::mem::offset_of!(HFFaceFeatureIdentity, feature) - 16usize];
};
#[doc = " @brief Struct representing the identity of a face feature.\n\n This struct associates a custom identifier and a tag with a specific face feature."]
pub type PHFFaceFeatureIdentity = *mut HFFaceFeatureIdentity;
#[doc = " Search structure for top-k mode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFSearchTopKResults {
    #[doc = "< The number of faces searched"]
    pub size: HInt32,
    #[doc = "< Search confidence(it has already been filtered once by the threshold)"]
    pub confidence: HPFloat,
    #[doc = "< fACE customIds"]
    pub customIds: HPInt32,
}
const _: () = {
    ["Size of HFSearchTopKResults"][::std::mem::size_of::<HFSearchTopKResults>() - 24usize];
    ["Alignment of HFSearchTopKResults"][::std::mem::align_of::<HFSearchTopKResults>() - 8usize];
    ["Offset of field: HFSearchTopKResults::size"]
        [::std::mem::offset_of!(HFSearchTopKResults, size) - 0usize];
    ["Offset of field: HFSearchTopKResults::confidence"]
        [::std::mem::offset_of!(HFSearchTopKResults, confidence) - 8usize];
    ["Offset of field: HFSearchTopKResults::customIds"]
        [::std::mem::offset_of!(HFSearchTopKResults, customIds) - 16usize];
};
#[doc = " Search structure for top-k mode"]
pub type PHFSearchTopKResults = *mut HFSearchTopKResults;
extern "C" {
    #[doc = " @brief Set the face recognition search threshold.\n\n This function sets the threshold for face recognition, which determines the sensitivity\n of the recognition process. A lower threshold may yield more matches but with less confidence.\n\n @param threshold The threshold value to set for face recognition (default is 0.48, suitable for\n access control scenarios).\n @return HResult indicating the success or failure of the operation."]
    pub fn HFFeatureHubFaceSearchThresholdSetting(threshold: f32) -> HResult;
}
extern "C" {
    #[doc = " @brief Perform a one-to-one comparison of two face features.\n\n @param session Handle to the session.\n @param feature1 The first face feature for comparison.\n @param feature2 The second face feature for comparison.\n @param result Pointer to the floating-point value where the comparison result will be stored.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFFaceComparison(
        feature1: HFFaceFeature,
        feature2: HFFaceFeature,
        result: HPFloat,
    ) -> HResult;
}
extern "C" {
    #[doc = " @brief Get the length of the face feature.\n\n @param num Pointer to an integer where the length of the feature will be stored.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFGetFeatureLength(num: HPInt32) -> HResult;
}
extern "C" {
    #[doc = " @brief Insert a face feature identity into the features group.\n\n @param featureIdentity The face feature identity to be inserted.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFFeatureHubInsertFeature(featureIdentity: HFFaceFeatureIdentity) -> HResult;
}
extern "C" {
    #[doc = " @brief Search for the most similar face feature in the features group.\n\n @param searchFeature The face feature to be searched.\n @param confidence Pointer to a floating-point value where the confidence level of the match will\n be stored.\n @param mostSimilar Pointer to the most similar face feature identity found.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFFeatureHubFaceSearch(
        searchFeature: HFFaceFeature,
        confidence: HPFloat,
        mostSimilar: PHFFaceFeatureIdentity,
    ) -> HResult;
}
extern "C" {
    #[doc = " @brief Search for the most similar k facial features in the feature group\n\n @param searchFeature The face feature to be searched.\n @param confidence topK Maximum number of searches\n @param PHFSearchTopKResults Output search result\n @return HResult indicating the success or failure of the operation."]
    pub fn HFFeatureHubFaceSearchTopK(
        searchFeature: HFFaceFeature,
        topK: HInt32,
        results: PHFSearchTopKResults,
    ) -> HResult;
}
extern "C" {
    #[doc = " @brief Remove a face feature from the features group based on custom ID.\n\n @param customId The custom ID of the feature to be removed.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFFeatureHubFaceRemove(customId: HInt32) -> HResult;
}
extern "C" {
    #[doc = " @brief Update a face feature identity in the features group.\n\n @param featureIdentity The face feature identity to be updated.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFFeatureHubFaceUpdate(featureIdentity: HFFaceFeatureIdentity) -> HResult;
}
extern "C" {
    #[doc = " @brief Retrieve a face feature identity from the features group based on custom ID.\n\n @param customId The custom ID of the feature.\n @param identity Pointer to the face feature identity to be retrieved.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFFeatureHubGetFaceIdentity(
        customId: HInt32,
        identity: PHFFaceFeatureIdentity,
    ) -> HResult;
}
extern "C" {
    #[doc = " @brief Get the count of face features in the features group.\n\n @param count Pointer to an integer where the count of features will be stored.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFFeatureHubGetFaceCount(count: *mut HInt32) -> HResult;
}
extern "C" {
    #[doc = " @brief View the face database table.\n\n @return HResult indicating the success or failure of the operation."]
    pub fn HFFeatureHubViewDBTable() -> HResult;
}
extern "C" {
    #[doc = " @brief Process multiple faces in a pipeline.\n\n This function processes multiple faces detected in an image or video frame, applying\n various face recognition and analysis features as specified in the parameters.\n\n @param session Handle to the session.\n @param streamHandle Handle to the data buffer representing the camera stream component.\n @param faces Pointer to the structure containing data of multiple detected faces.\n @param parameter Custom parameters for processing the faces.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFMultipleFacePipelineProcess(
        session: HFSession,
        streamHandle: HFImageStream,
        faces: PHFMultipleFaceData,
        parameter: HFSessionCustomParameter,
    ) -> HResult;
}
extern "C" {
    #[doc = " @brief Process multiple faces in a pipeline with an optional custom option.\n\n Similar to HFMultipleFacePipelineProcess, but allows for additional custom options\n to modify the face processing behavior.\n\n @param session Handle to the session.\n @param streamHandle Handle to the data buffer representing the camera stream component.\n @param faces Pointer to the structure containing data of multiple detected faces.\n @param customOption An integer representing a custom option for processing.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFMultipleFacePipelineProcessOptional(
        session: HFSession,
        streamHandle: HFImageStream,
        faces: PHFMultipleFaceData,
        customOption: HInt32,
    ) -> HResult;
}
#[doc = " @brief Struct representing RGB liveness confidence.\n\n This struct holds the number of faces and the confidence level of liveness detection\n for each face, using RGB analysis."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFRGBLivenessConfidence {
    #[doc = "< Number of faces detected."]
    pub num: HInt32,
    #[doc = "< Confidence level of RGB liveness detection for each face."]
    pub confidence: HPFloat,
}
const _: () = {
    ["Size of HFRGBLivenessConfidence"][::std::mem::size_of::<HFRGBLivenessConfidence>() - 16usize];
    ["Alignment of HFRGBLivenessConfidence"]
        [::std::mem::align_of::<HFRGBLivenessConfidence>() - 8usize];
    ["Offset of field: HFRGBLivenessConfidence::num"]
        [::std::mem::offset_of!(HFRGBLivenessConfidence, num) - 0usize];
    ["Offset of field: HFRGBLivenessConfidence::confidence"]
        [::std::mem::offset_of!(HFRGBLivenessConfidence, confidence) - 8usize];
};
#[doc = " @brief Struct representing RGB liveness confidence.\n\n This struct holds the number of faces and the confidence level of liveness detection\n for each face, using RGB analysis."]
pub type PHFRGBLivenessConfidence = *mut HFRGBLivenessConfidence;
extern "C" {
    #[doc = " @brief Get the RGB liveness confidence.\n\n This function retrieves the confidence level of RGB liveness detection for faces detected\n in the current context.\n\n @param session Handle to the session.\n @param confidence Pointer to the structure where RGB liveness confidence data will be stored.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFGetRGBLivenessConfidence(
        session: HFSession,
        confidence: PHFRGBLivenessConfidence,
    ) -> HResult;
}
#[doc = " @brief Struct representing face mask confidence.\n\n This struct holds the number of faces and the confidence level of mask detection\n for each face."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFFaceMaskConfidence {
    #[doc = "< Number of faces detected."]
    pub num: HInt32,
    #[doc = "< Confidence level of mask detection for each face."]
    pub confidence: HPFloat,
}
const _: () = {
    ["Size of HFFaceMaskConfidence"][::std::mem::size_of::<HFFaceMaskConfidence>() - 16usize];
    ["Alignment of HFFaceMaskConfidence"][::std::mem::align_of::<HFFaceMaskConfidence>() - 8usize];
    ["Offset of field: HFFaceMaskConfidence::num"]
        [::std::mem::offset_of!(HFFaceMaskConfidence, num) - 0usize];
    ["Offset of field: HFFaceMaskConfidence::confidence"]
        [::std::mem::offset_of!(HFFaceMaskConfidence, confidence) - 8usize];
};
#[doc = " @brief Struct representing face mask confidence.\n\n This struct holds the number of faces and the confidence level of mask detection\n for each face."]
pub type PHFFaceMaskConfidence = *mut HFFaceMaskConfidence;
extern "C" {
    #[doc = " @brief Get the face mask confidence.\n\n This function retrieves the confidence level of mask detection for faces detected\n in the current context.\n\n @param session Handle to the session.\n @param confidence Pointer to the structure where face mask confidence data will be stored.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFGetFaceMaskConfidence(
        session: HFSession,
        confidence: PHFFaceMaskConfidence,
    ) -> HResult;
}
#[doc = " @brief Struct representing face quality predict confidence.\n\n This struct holds the number of faces and the confidence level of face quality predict\n for each face."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFFaceQualityConfidence {
    #[doc = "< Number of faces detected."]
    pub num: HInt32,
    #[doc = "< Confidence level of face quality predict for each face."]
    pub confidence: HPFloat,
}
const _: () = {
    ["Size of HFFaceQualityConfidence"][::std::mem::size_of::<HFFaceQualityConfidence>() - 16usize];
    ["Alignment of HFFaceQualityConfidence"]
        [::std::mem::align_of::<HFFaceQualityConfidence>() - 8usize];
    ["Offset of field: HFFaceQualityConfidence::num"]
        [::std::mem::offset_of!(HFFaceQualityConfidence, num) - 0usize];
    ["Offset of field: HFFaceQualityConfidence::confidence"]
        [::std::mem::offset_of!(HFFaceQualityConfidence, confidence) - 8usize];
};
#[doc = " @brief Struct representing face quality predict confidence.\n\n This struct holds the number of faces and the confidence level of face quality predict\n for each face."]
pub type PHFFaceQualityConfidence = *mut HFFaceQualityConfidence;
extern "C" {
    #[doc = " @brief Get the face quality predict confidence.\n\n This function retrieves the confidence level of face quality predict for faces detected\n in the current context.\n\n @param session Handle to the session.\n @param confidence Pointer to the structure where face mask confidence data will be stored.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFGetFaceQualityConfidence(
        session: HFSession,
        confidence: PHFFaceQualityConfidence,
    ) -> HResult;
}
extern "C" {
    #[doc = " @brief Detect the quality of a face in an image.\n\n This function assesses the quality of a detected face, such as its clarity and visibility.\n\n @param session Handle to the session.\n @param singleFace A token representing a single face.\n @param confidence Pointer to a floating-point value where the quality confidence will be stored.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFFaceQualityDetect(
        session: HFSession,
        singleFace: HFFaceBasicToken,
        confidence: *mut HFloat,
    ) -> HResult;
}
#[doc = " @brief Facial states in the face interaction module."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFFaceIntereactionState {
    #[doc = "< Number of faces detected."]
    pub num: HInt32,
    #[doc = "< Left eye state: confidence close to 1 means open, close\n< to 0 means closed."]
    pub leftEyeStatusConfidence: HPFloat,
    #[doc = "< Right eye state: confidence close to 1 means open, close\n< to 0 means closed."]
    pub rightEyeStatusConfidence: HPFloat,
}
const _: () = {
    ["Size of HFFaceIntereactionState"][::std::mem::size_of::<HFFaceIntereactionState>() - 24usize];
    ["Alignment of HFFaceIntereactionState"]
        [::std::mem::align_of::<HFFaceIntereactionState>() - 8usize];
    ["Offset of field: HFFaceIntereactionState::num"]
        [::std::mem::offset_of!(HFFaceIntereactionState, num) - 0usize];
    ["Offset of field: HFFaceIntereactionState::leftEyeStatusConfidence"]
        [::std::mem::offset_of!(HFFaceIntereactionState, leftEyeStatusConfidence) - 8usize];
    ["Offset of field: HFFaceIntereactionState::rightEyeStatusConfidence"]
        [::std::mem::offset_of!(HFFaceIntereactionState, rightEyeStatusConfidence) - 16usize];
};
#[doc = " @brief Facial states in the face interaction module."]
pub type PHFFaceIntereactionState = *mut HFFaceIntereactionState;
extern "C" {
    #[doc = " @brief Get the prediction results of face interaction.\n @param session Handle to the session.\n @param result Facial state prediction results in the face interaction module."]
    pub fn HFGetFaceIntereactionStateResult(
        session: HFSession,
        result: PHFFaceIntereactionState,
    ) -> HResult;
}
#[doc = " @brief Actions detected in the face interaction module."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFFaceIntereactionsActions {
    #[doc = "< Number of actions detected."]
    pub num: HInt32,
    #[doc = "< Normal actions."]
    pub normal: HPInt32,
    #[doc = "< Shake actions."]
    pub shake: HPInt32,
    #[doc = "< Jaw open actions."]
    pub jawOpen: HPInt32,
    #[doc = "< Head raise actions."]
    pub headRiase: HPInt32,
    #[doc = "< Blink actions."]
    pub blink: HPInt32,
}
const _: () = {
    ["Size of HFFaceIntereactionsActions"]
        [::std::mem::size_of::<HFFaceIntereactionsActions>() - 48usize];
    ["Alignment of HFFaceIntereactionsActions"]
        [::std::mem::align_of::<HFFaceIntereactionsActions>() - 8usize];
    ["Offset of field: HFFaceIntereactionsActions::num"]
        [::std::mem::offset_of!(HFFaceIntereactionsActions, num) - 0usize];
    ["Offset of field: HFFaceIntereactionsActions::normal"]
        [::std::mem::offset_of!(HFFaceIntereactionsActions, normal) - 8usize];
    ["Offset of field: HFFaceIntereactionsActions::shake"]
        [::std::mem::offset_of!(HFFaceIntereactionsActions, shake) - 16usize];
    ["Offset of field: HFFaceIntereactionsActions::jawOpen"]
        [::std::mem::offset_of!(HFFaceIntereactionsActions, jawOpen) - 24usize];
    ["Offset of field: HFFaceIntereactionsActions::headRiase"]
        [::std::mem::offset_of!(HFFaceIntereactionsActions, headRiase) - 32usize];
    ["Offset of field: HFFaceIntereactionsActions::blink"]
        [::std::mem::offset_of!(HFFaceIntereactionsActions, blink) - 40usize];
};
#[doc = " @brief Actions detected in the face interaction module."]
pub type PHFFaceIntereactionsActions = *mut HFFaceIntereactionsActions;
extern "C" {
    #[doc = " @brief Get the prediction results of face interaction actions.\n @param session Handle to the session.\n @param actions Facial action prediction results in the face interaction module.\n @return HResult indicating success or failure of the function call."]
    pub fn HFGetFaceIntereactionActionsResult(
        session: HFSession,
        actions: PHFFaceIntereactionsActions,
    ) -> HResult;
}
#[doc = " @brief Struct representing face attribute results.\n\n This struct holds the race, gender, and age bracket attributes for a detected face."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFFaceAttributeResult {
    #[doc = "< Number of faces detected."]
    pub num: HInt32,
    #[doc = "< Race of the detected face.\n< 0: Black;\n< 1: Asian;\n< 2: Latino/Hispanic;\n< 3: Middle Eastern;\n< 4: White;"]
    pub race: HPInt32,
    #[doc = "< Gender of the detected face.\n< 0: Female;\n< 1: Male;"]
    pub gender: HPInt32,
    #[doc = "< Age bracket of the detected face.\n< 0: 0-2 years old;\n< 1: 3-9 years old;\n< 2: 10-19 years old;\n< 3: 20-29 years old;\n< 4: 30-39 years old;\n< 5: 40-49 years old;\n< 6: 50-59 years old;\n< 7: 60-69 years old;\n< 8: more than 70 years old;"]
    pub ageBracket: HPInt32,
}
const _: () = {
    ["Size of HFFaceAttributeResult"][::std::mem::size_of::<HFFaceAttributeResult>() - 32usize];
    ["Alignment of HFFaceAttributeResult"]
        [::std::mem::align_of::<HFFaceAttributeResult>() - 8usize];
    ["Offset of field: HFFaceAttributeResult::num"]
        [::std::mem::offset_of!(HFFaceAttributeResult, num) - 0usize];
    ["Offset of field: HFFaceAttributeResult::race"]
        [::std::mem::offset_of!(HFFaceAttributeResult, race) - 8usize];
    ["Offset of field: HFFaceAttributeResult::gender"]
        [::std::mem::offset_of!(HFFaceAttributeResult, gender) - 16usize];
    ["Offset of field: HFFaceAttributeResult::ageBracket"]
        [::std::mem::offset_of!(HFFaceAttributeResult, ageBracket) - 24usize];
};
#[doc = " @brief Struct representing face attribute results.\n\n This struct holds the race, gender, and age bracket attributes for a detected face."]
pub type PHFFaceAttributeResult = *mut HFFaceAttributeResult;
extern "C" {
    #[doc = " @brief Get the face attribute results.\n\n This function retrieves the attribute results such as race, gender, and age bracket\n for faces detected in the current context.\n\n @param session Handle to the session.\n @param results Pointer to the structure where face attribute results will be stored.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFGetFaceAttributeResult(session: HFSession, results: PHFFaceAttributeResult)
        -> HResult;
}
#[doc = " @brief Structure representing the version information of the InspireFace library."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HFInspireFaceVersion {
    #[doc = "< Major version number."]
    pub major: ::std::os::raw::c_int,
    #[doc = "< Minor version number."]
    pub minor: ::std::os::raw::c_int,
    #[doc = "< Patch version number."]
    pub patch: ::std::os::raw::c_int,
}
const _: () = {
    ["Size of HFInspireFaceVersion"][::std::mem::size_of::<HFInspireFaceVersion>() - 12usize];
    ["Alignment of HFInspireFaceVersion"][::std::mem::align_of::<HFInspireFaceVersion>() - 4usize];
    ["Offset of field: HFInspireFaceVersion::major"]
        [::std::mem::offset_of!(HFInspireFaceVersion, major) - 0usize];
    ["Offset of field: HFInspireFaceVersion::minor"]
        [::std::mem::offset_of!(HFInspireFaceVersion, minor) - 4usize];
    ["Offset of field: HFInspireFaceVersion::patch"]
        [::std::mem::offset_of!(HFInspireFaceVersion, patch) - 8usize];
};
#[doc = " @brief Structure representing the version information of the InspireFace library."]
pub type PHFInspireFaceVersion = *mut HFInspireFaceVersion;
extern "C" {
    #[doc = " @brief Function to query the version information of the InspireFace library.\n\n This function retrieves the version information of the InspireFace library.\n\n @param version Pointer to the structure where the version information will be stored.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFQueryInspireFaceVersion(version: PHFInspireFaceVersion) -> HResult;
}
pub const HFLogLevel_HF_LOG_NONE: HFLogLevel = 0;
pub const HFLogLevel_HF_LOG_DEBUG: HFLogLevel = 1;
pub const HFLogLevel_HF_LOG_INFO: HFLogLevel = 2;
pub const HFLogLevel_HF_LOG_WARN: HFLogLevel = 3;
pub const HFLogLevel_HF_LOG_ERROR: HFLogLevel = 4;
pub const HFLogLevel_HF_LOG_FATAL: HFLogLevel = 5;
#[doc = " @brief SDK built-in log level mode"]
pub type HFLogLevel = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @brief Set the log level built into the SDK.The default is HF LOG DEBUG"]
    pub fn HFSetLogLevel(level: HFLogLevel) -> HResult;
}
extern "C" {
    #[doc = " @brief Disable the log function. Like HFSetLogLevel(HF_LOG_NONE)"]
    pub fn HFLogDisable() -> HResult;
}
extern "C" {
    #[doc = " @brief Display an image stream for debugging purposes.\n\n This function is used for debugging, allowing the visualization of the image stream\n as it is being processed. It can be useful to understand the data being received\n from the camera or image source.\n\n @param streamHandle Handle to the data buffer representing the camera stream component."]
    pub fn HFDeBugImageStreamImShow(streamHandle: HFImageStream);
}
extern "C" {
    #[doc = " @brief Decode the image from ImageStream and store it to a disk path.\n\n It is used to verify whether there is a problem with image codec, and can quickly perform bug\n analysis.\n\n @param streamHandle Handle to the data buffer representing the camera stream component.\n @param savePath The path to which the image is written.\n @return HResult indicating the success or failure of the operation."]
    pub fn HFDeBugImageStreamDecodeSave(streamHandle: HFImageStream, savePath: HPath) -> HResult;
}
extern "C" {
    #[doc = " @brief Display current resource management statistics.\n\n This function prints statistics about the resources managed by the ResourceManager,\n including the total number of created and released sessions and image streams, as well as\n the count of those that have not been released yet. This can be used for debugging purposes\n to ensure that resources are being properly managed and to identify potential resource leaks.\n\n @return HResult indicating the success or failure of the operation.\n         Returns HSUCCEED if the statistics were successfully displayed,\n         otherwise, it may return an error code if there is an issue accessing the resource\n manager."]
    pub fn HFDeBugShowResourceStatistics() -> HResult;
}
